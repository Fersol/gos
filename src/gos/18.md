# 18. Методы аутентификации в сети. Протокол аутентификации Kerberos.

## Основные определения

**Идентификация** — это процесс распознавания элемента системы, обычно с помощью заранее определённого идентификатора или другой уникальной информации — каждый субъект или объект системы должен быть однозначно идентифицируем.

**Аутентификация** — это проверка подлинности идентификации пользователя, процесса, устройства или другого компонента системы (обычно осуществляется перед разрешением доступа).

Идентификация и аутентификация — взаимосвязанные процессы распознавания и проверки подлинности субъектов (пользователей). Именно от них зависит решение системы, можно ли разрешить доступ к ресурсам системы конкретному пользователю или процессу. 

После того как субъект *идентифицирован и аутентифицирован,* выполняется его *авторизация*.

## Методы идентификации на основе секрета 

- **Простая аутентификация** (на основе использования паролей);

- **Строгая аутентификация** (на основе использования криптографических методов и средств);

- Процессы (протоколы) аутентификации, обладающие свойством доказательства **с нулевым знанием.**

Слабость простой аутентификации именно в самом пароле и человеческом факторе. Далее рассматриваем строгую аутентификацию.

## Строгая аутентификация

Идея строгой аутентификации, реализуемая в криптографических протоколах, заключается в следующем. Проверяемая (доказывающая) сторона доказывает свою подлинность проверяющей стороне, демонстрируя знание какого-либо секрета, который, например, может быть предварительно распределен безопасным способом между сторонами аутентификационного обмена. Важно, что доказывающая сторона демонстрирует только знание секрета, но сам он в ходе аутентификационного обмена не раскрывается.

В соответствии с рекомендациями стандарта Х.509 различают процедуры строгой аутентификации следующих типов:

- односторонняя аутентификация;

- двусторонняя аутентификация;

- трехсторонняя аутентификация.

В зависимости от используемых криптографических алгоритмов протоколы строгой аутентификации можно разделить на следующие группы:

- протоколы аутентификации на основе симметричных алгоритмов;

- протоколы аутентификации на основе хэш-функций;

- протоколы аутентификации на основе асимметричных алгоритмов;

- протоколы аутентификации на основе цифровой подписи.

Так как билет про Kerberos, далее рассматриваются  протоколы аутентификации на основе симметричных алгоритмов. На всякий случай вспомним:

**Симметричное шифрование** — способ шифрования, в котором для шифрования  и расшифровывания применяется один и тот же криптографический ключ.

Простой пример как можно сделать двустороннюю аутентификацию на симметричном шифровании:

(1) $A \leftarrow B: R_B$

(2) $A \rightarrow B: E_K (R_A ,R_B ,B)$

(3) $A \leftarrow B: E_K (R_A ,R_B )$

Шаг 0: A и B хотят взаимно аутентифицироваться, симметричный ключ $E_K$ есть у обоих участников

Шаг 1: Участник B посылает участнику A случайное число

Шаг 2: Участник A отвечает зашифрованной $E_K$ последовательностью из принятого числа, еще одного случайного числа и идентификатора B.

Шаг 3: Участник B отвечает зашифрованной последовательностью из двух ранее посланных случайных чисел.

## KDC

Помимо аутентификации нужно еще генерировать ключ сессии для шифрования пользовательских данных, которые мы хотим послать (а шифровать все одним ключом не по феншую), поэтому для обеспечения аутентификации и распределения ключа сессии в сети используется двухуровневая иерархия ключей симметричного шифрования, которая используется двумя сторонами или основана на использовании доверенного центра (3-й стороны) распределения ключей (KDC).

Рассмотрим вариант с KDC.

Каждый участник разделяет секретный ключ, называемый также мастер-ключом, с KDC. KDC отвечает за создание ключей, называемых ключами сессии, и за распределение этих ключей с использованием мастер-ключей. Ключи сессии применяются для шифрования только данной сессии между двумя участниками.

Существует много протоколов, реализующих эту идею, нам будет важен протокол Нидхэма-Шредера, взятый за основу для Kerberos. Опять же, у протокола много вариантов, рассмотрим самый базовый.

1. $A \rightarrow KDC: ID_a || ID_b || N_a $
2. $KDC \rightarrow A: E_{K_a} [K_s || ID_b || N_a ] \\ E_{K_b} [K_s || ID_a ]$
3. $A \rightarrow B: E_{K_b} [K_s || ID_a ]$
4. $B \rightarrow A: E_{K_s} [N_b]$
5. $A \rightarrow B: E_{K_s} [f (N_b )]$

Шаг 0: Предполагается, что секретные мастер-ключи $K_a$ и $K_b$ разделяют соответственно А и KDC, В и KDC. Целью протокола является аутентификация и безопасное распределение ключа сессии $K_s$ между А и В

Шаг 1: А запрашивает у KDC ключ сессии для установления защищенного соединения с В. Сообщение включает идентификаторы А и В и уникальный идентификатор (номер) данной транзакции, который обозначен как $N_a$ — он должен быть уникальным для каждого запроса — суть идентификатор сессии, не дает ей повториться. Сообщение зашифровано мастер-ключом $K_a$.

Шаг 2: Все и так понятно, $K_s$ это ключ сессии, приходит 2 сообщения к стороне A.

Шаг 3: A передает второе сообщение от KDC на B.

Шаг 4 и 5: По сути проверка сессионного ключа: $N_b$ случайное число, $f$ известная функция (например квадрат числа). 

## Kerberos

- Протокол аутентификации пользователей на основе доверенной третьей стороны (KDC)
- Работает по умолчанию при доменной аутентификации в Windows (можно настроить и для linux с AD контроллером на винде, причем вы не только сможете логиниться с linux машины на сервисы с доменной аутентификацией, но и сами ее проводить, шок да и только), но если живете в чисто linux мире вредил вам это понадобиться, скорее всего ограничитесь x509 сертами.
- Использует в качестве транспорта протокол TCP. Ну как бы очевидно.
- Сама система работает прозрачно для пользователя, он просто вводит пароль

### Протокол с билетом

Сервер аутентификации Kerberos использует развитие двухуровневой системы аутентификации на основе применения концепции “билетов/мандатов”.

1. $A → B: ID_a || N_a $
2. $B → KDC: ID_b || N_b || E_{K_b} [ID_a || N_a || T_b ]$
3. $KDC → A: E_{K_a} [ID_b || N_a || K_s || T_b ||\\ E_{K_b} [ID_a || K_s || T_b] || N_b ]$ 
4. $A → B: E_{K_b} [ID_a || K_s || T_b ] || E_{K_s} [N_b ]$


Шаг 0: Предполагается, что секретные мастер-ключи $K_a$ и $K_b$ разделяют соответственно А и KDC, В и KDC. Целью протокола является аутентификация и безопасное распределение ключа сессии $K_s$ между А и В

Шаг 1: А инициализирует аутентификационный обмен созданием идентификатора $N_a$ и посылкой его и своего идентификатора к В в незашифрованном виде. Этот $N_a$ вернется к А в зашифрованном сообщении, включающем ключ сессии, гарантируя А, что ключ сессии не старый.

Шаг 2: B сообщает KDC, что необходим ключ сессии. Это сообщение к KDС включает идентификатор В и $N_b$. Данный $N_b$ вернется к В в зашифрованном сообщении, которое включает ключ сессии, гарантируя B, что ключ сессии не устарел. Последний блок используется для указания KDC, когда заканчивается время жизни $T_b$  данного ключа сессии и специфицирует намеченного получателя и содержит $N_a$ , полученный от A. 

Шаг 3: Да, да это одно сообщение, но можно и два, ничего не изменит. KDC получил $N_a$ и $N_b$ от А и В и посылает A блок, зашифрованный секретным ключом, который В разделяет с KDC. Блок служит **билетом**, который может быть использован А для последующих аутентификаций. KDC также посылает А блок, зашифрованный секретным ключом, разделяемым А и KDC, что доказывает:

- В получил начальное сообщение А ($ID_b$ );
- в нем содержится допустимая отметка времени и нет повтора ($N_a$).

То есть запомним **билет** это: $E_{K_b} [ID_a || K_s || T_b]$

Шаг 4: А посылает полученный билет В вместе с Nb , зашифрованным ключом сессии. Этот билет обеспечивает В ключом сессии, который тот использует для дешифрования и проверки $N_b$ . Тот факт, что $N_b$ расшифрован ключом сессии, доказывает, что сообщение пришло от А и не является повтором.

Вот и все, это основная идея, осталось повторить 2 раза.

Данный протокол аутентифицирует А и В и распределяет ключ сессии. Более того, протокол предоставляет в распоряжение А билет, который может использоваться для его последующей аутентификации, исключая необходимость повторных контактов с аутентификационным сервером.

### Мандаты на мандаты в Kerberos

В протоколе аутентификации Kerberos используются два уровня билетов (мандат на право получения билета и собственно билет) и следовательно имеем 2 сервера:

- Kerberos — сервера аутентификации\центра распространения ключей (KDC\AS), который выдает мандат (“главный билет”)
- TGS сервер, для выдачи “билетов” (вторичных мандатов) для доступа к сетевым службам.

По сути, это разделение функций аутентификации и авторизации.

Процедура получения мандата, за счет использования меток времени вместо случайных номеров, сокращена по сравнению с описанной выше:

1. $A \rightarrow KDC: ID_a || ID_{tgs} || T_a $

2. $KDC \rightarrow A: E_{K_a} [ID_{tgs} || K_{a-tgs} || T_{tgs} || (\delta T_{tgs} ) || (M_{tgs} ) ]$, где M (**мандат**):

$$
(M_{tgs} ) = E_{K_{tgs}} [ID_a || K_{a-tgs} || AD_a || ID_{tgs} || T_{tgs} || (\delta T_{tgs} )]
$$



В отличие от описанной выше схемы $N_x$ заменены на временные метки $T_x$ и срок ($\delta T_x$) для объекта х. Добавлен параметр сетевой адрес A - $AD_a$ и В заменен на TGS (соответственно сеансовый ключ стал обозначаться $K_{a-tgs}$ , а общий секрет TGS и KDC — $K_{tgs}$ ).

Важно, что сообщение (2) шифруется общим секретом A и KDC (разделяемым ключом или его генерацией на основе пароля пользователя), а следующие сообщения шифруются уже полученным сеансовым ключом.

После этого на основе этого мандата можно обращаться в TGS за вторичными мандатами (билетами), на каждый новый сервис (например B). Билет (мандат) на получение сервиса имеет ту же структуру, что и мандат на получение мандата:

(Билет B) = $E_{Kb} [ID_a || K_{s-b} || AD_a || ID_b || T_b || (\delta T_b ) ]$

Таким образом, пользователь сначала запрашивает мандат на получение мандата (Мандат TGS ) у сервера аутентификации AS.

Этот мандат сохраняется модулем клиента на рабочей станции пользователя. Каждый раз, когда пользователю требуется новый сервис, клиент обращается к TGS и использует этот мандат, чтобы идентифицировать себя.

В ответ TGS выдает билет (вторичный мандат) на получение конкретного сервиса. Клиент сохраняет билет на получение сервиса и использует его для идентификации пользователя сервером всякий раз, когда запрашивается данный сервис.

Теперь рассмотрим как происходит получение итогового мандата (билета):

3. $A \rightarrow TGS: ID_b || M_{tgs} || U_{A_1}$

4. $TGS \rightarrow A: E_{K_{a-tgs}} [K_{a-b} || ID_b || Ts_4 || \delta Ts_2 || M_b ]$

Мандат tgs: $M_{tgs} = E_{K_{tgs}} [ID_a || K_{a-tgs} || AD_a || ID_{tgs} || T_{tgs} || (\delta T_{tgs} )]$

Мандат b: $M_b = E Kv [K_{a-b} || ID_a ||AD_a || ID_b || Ts_4 || \delta Ts_4 ] $

Удостоверение A1: $U_{A_1} = E_{K_{a-tgs}} [ID_a || AD_a || Ts_3 ]$

A передает удостоверение, включающее идентификатор и адрес пользователя A, а также метку даты-времени. В отличие от мандата, который предполагает многократное использование, удостоверение предлагается использовать только один раз и срок его действия весьма ограничен. TGS может сравнить содержащиеся в удостоверении имя и сетевой адрес с соответствующими элементами мандата и с сетевым адресом поступившего сообщения. Мандат никого не идентифицирует, а обеспечивает способ защищенного распределения ключей. Задачи аутентификации клиента выполняет удостоверение.

5. $A \rightarrow B: M_b|| U_{A_2}$

6. $B \rightarrow A: E_{K_{a-b}} [T_{s5} + 1] $

Удостоверение A2: $ U_{A_2} = E_{K_{a-b}} [ID_a || AD_a || Ts_5 ]$

Если требуется взаимная аутентификация, сервер может ответить так, как предлагается в сообщении (6). Сервер возвращает значение метки даты-времени из удостоверения, увеличенное на 1 и зашифрованное на сеансовом ключе. Система A может расшифровать это сообщение и проверить увеличенное значение метки даты-времени. Поскольку сообщение было зашифровано сеансовым ключом, A убеждается в том, что это сообщение могло быть создано только сервером B и не является воспроизведением старого ответа.

Итого все вместе:

- Обмен службы аутентификации: получение мандата на получение мандата:
  - $A \rightarrow KDC: ID_a || ID_{tgs} || T_a $
  - $KDC \rightarrow A: E_{K_a} [ID_{tgs} || K_{a-tgs} || T_{tgs} || (\delta T_{tgs} ) || (M_{tgs} ) ]$
- Обмен службы выдачи мандатов: получение мандата (билета) на получение сервиса
  - $A \rightarrow TGS: ID_b || M_{tgs} || U_{A_1}$
  - $TGS \rightarrow A: E_{K_{a-tgs}} [K_{a-b} || ID_b || Ts_4 || \delta Ts_2 || M_b ]$
- Обмен аутентификации клиента/сервера: получение сервиса
  - $A \rightarrow B: M_b|| U_{A_2}$
  - $B \rightarrow A: E_{K_{a-b}} [T_{s5} + 1] $

Ура

Заметим, что в Kerberos еще есть понятие области (домена, realm). И возможна также междоменная аутентификация. Сделать это можно разделив секретный ключ с интересующей областью. По факту появится 3-й уровень мандатов.

### Kerberos 5

Вышесказанное справедливо для Kerberos 4, в 5 версии был сделан ряд улучшений:

- версия 4 требует применения DES. В версии 5 к шифрованному тексту присоединяется идентификатор типа шифрования, поэтому может использоваться любая схема шифрования. Для ключей шифрования указываются длины, что позволяет использовать одни и те же ключи в различных алгоритмах и указывать варианты одного алгоритма для применения.
- сетевые адреса сопровождаются метками типа и длины, что дает возможность использовать любые типы сетевых адресов.
- включают явное указание времени начала и окончания действия мандата, что позволяет указывать любые сроки действия мандатов.
- оптимизация аутентификации в удаленной области.

Конечно поменялся и сам алгоритм, в мандаты добавились области, границы времени, флаги и на этом моменте стоит остановиться и при желании посмотреть слайды.

### Недостатки

**Версия 4** Kerberos имеет технические недостатки:

1. Двойное шифрование. Обратите внимание (сообщения 2 и 4), мандаты, выдаваемые клиентам, шифруются дважды — один раз секретным ключом сервера назначения, а затем снова, секретным ключом, известным клиенту. Второе шифрование не является необходимым, и поэтому вызывает излишнее потребление вычислительных ресурсов.
2. DES
3. Сеансовые ключи. Каждый мандат включает сеансовый ключ, используемый клиентом для шифрования удостоверений, посылаемых службе, связываемой с данным мандатом. Кроме того, этот сеансовый ключ может впоследствии использоваться клиентом и сервером для защиты сообщений, пересылаемых в ходе сеанса. Однако, ввиду того, что один и тот же мандат может использоваться повторно для получения соответствующего сервиса от конкретного сервера, существует риск, что нарушитель может предъявить клиенту или серверу воспроизведенные сообщения старого сеанса. В версии 5 для клиента и сервера существует возможность договориться о сеансовом подключе, который действует только в одном соединении. При новом доступе клиент должен будет использовать новый сеансовый подключ.

**Версии 4 и 5** Kerberos имеет технические недостатки:

1. Атаки на пароль. Обе версии уязвимы в отношении атак на пароль. Сообщение клиенту от системы AS включает данные, зашифрованные с помощью ключа, построенного на основе пароля клиента. Нарушитель может перехватить это сообщение и попытаться дешифровать его, используя разные пароли. Если в результате попыток расшифрования получится сообщение правильного вида, то нарушитель узнает пароль клиента и сможет впоследствии использовать этот пароль для того, чтобы получать удостоверения аутентификации от Kerberos. Версия 5 предлагает механизм, называемый предварительной аутентификацией, призванный затруднить атаки на пароль, но не исключает их возможность полностью.